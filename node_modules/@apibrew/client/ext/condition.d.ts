import { ExtensionInfo } from "../extension-info";
import { Entity } from "../entity";
import { Event } from "../model/extension";
import { EntityInfo } from "../entity-info";
export interface Condition<T extends Entity> {
    configureExtensionInfo(extensionInfo: ExtensionInfo): ExtensionInfo;
    eventMatches(event: Event, entity: T): boolean;
}
export declare class SimpleCondition<T extends Entity> implements Condition<T> {
    private readonly configureExtensionInfoFn;
    private readonly eventMatchesFn;
    constructor(configureExtensionInfoFn: (extensionInfo: ExtensionInfo) => ExtensionInfo, eventMatchesFn: (event: Event, entity: T) => boolean);
    configureExtensionInfo(extensionInfo: ExtensionInfo): ExtensionInfo;
    eventMatches(event: Event, entity: T): boolean;
}
export declare function and<T extends Entity>(condition1: Condition<T>, condition2: Condition<T>): Condition<T>;
export declare function or<T extends Entity>(condition1: Condition<T>, condition2: Condition<T>): Condition<T>;
export declare function not<T extends Entity>(condition: Condition<T>): Condition<T>;
export declare function before<T extends Entity>(): Condition<T>;
export declare function after<T extends Entity>(): Condition<T>;
export declare function on<T extends Entity>(customActionName: string): Condition<T>;
export declare function create<T extends Entity>(): Condition<T>;
export declare function update<T extends Entity>(): Condition<T>;
export declare function delete$<T extends Entity>(): Condition<T>;
export declare function get<T extends Entity>(): Condition<T>;
export declare function list<T extends Entity>(): Condition<T>;
export declare function beforeCreate<T extends Entity>(): Condition<T>;
export declare function beforeUpdate<T extends Entity>(): Condition<T>;
export declare function beforeDelete<T extends Entity>(): Condition<T>;
export declare function beforeGet<T extends Entity>(): Condition<T>;
export declare function beforeList<T extends Entity>(): Condition<T>;
export declare function afterCreate<T extends Entity>(): Condition<T>;
export declare function afterUpdate<T extends Entity>(): Condition<T>;
export declare function afterList<T extends Entity>(): Condition<T>;
export declare function afterDelete<T extends Entity>(): Condition<T>;
export declare function afterGet<T extends Entity>(): Condition<T>;
export declare function onAction<T extends Entity>(customActionName: string): Condition<T>;
export declare function async<T extends Entity>(): Condition<T>;
export declare function entityExists<T extends Entity>(): Condition<T>;
export declare function user<T extends Entity>(...expectedUsers: string[]): Condition<T>;
export declare function resource<T extends Entity>(namespace: string, ...resource: string[]): Condition<T>;
export declare function resourceFromEntityInfo<T extends Entity>(entityInfo: EntityInfo): Condition<T>;
export declare function group<T extends Entity>(...expectedGroups: string[]): Condition<T>;
export declare const Condition: {
    and: typeof and;
    or: typeof or;
    before: typeof before;
    after: typeof after;
    on: typeof on;
    create: typeof create;
    update: typeof update;
    delete: typeof delete$;
    get: typeof get;
    list: typeof list;
    beforeCreate: typeof beforeCreate;
    beforeUpdate: typeof beforeUpdate;
    beforeDelete: typeof beforeDelete;
    beforeGet: typeof beforeGet;
    beforeList: typeof beforeList;
    afterCreate: typeof afterCreate;
    afterUpdate: typeof afterUpdate;
    afterList: typeof afterList;
    afterDelete: typeof afterDelete;
    afterGet: typeof afterGet;
    onAction: typeof onAction;
    async: typeof async;
    entityExists: typeof entityExists;
    user: typeof user;
    resource: typeof resource;
    resourceFromEntityInfo: typeof resourceFromEntityInfo;
    group: typeof group;
};
