import { Client } from '../client';
import { Resource } from "../model/resource";
import { AxiosResponse } from "axios";
import { Event } from "../model/extension";
import { Container } from "../container";
import { Entity } from "../entity";
import { EntityInfo } from "../entity-info";
import { Repository } from "../repository";
import { Server } from "../config";
import { ListRecordParams } from "../list-record-params";
import { GetRecordParams } from "../get-record-params";
import { TokenStorage } from '../token-storage';
import { TokenBody } from '../token-body';
export declare class Urls {
    static resourceUrl(url: string): string;
    static resourceByName(url: string, namespace: string, name: string): string;
    static resourceById(url: string, id: string): string;
    static recordUrl(url: string, restPath: string): string;
    static recordSearchUrl(url: string, restPath: string): string;
    static recordWatchUrl(url: string, restPath: string, filters?: {
        [key: string]: string;
    }): string;
    static recordByIdUrl(url: string, restPath: string, id: string): string;
    static recordActionByIdUrl(url: string, restPath: string, id: string, action: string): string;
    static authenticate(url: string): string;
    static eventsUrl(url: string): string;
}
export declare class DefaultTokenStorage implements TokenStorage {
    private data;
    clear(): void;
    get(name: string): string | undefined;
    set(name: string, token: string): void;
    list(): {
        name: string;
        token: string;
    }[];
}
export declare class ClientImpl implements Client {
    private url;
    private bypassExtensionsEnabled;
    private tokenStorage;
    private tokenRefreshInterval?;
    constructor(url: string);
    useTokenStorage(tokenStorage: TokenStorage): void;
    static ensureResponseSuccess(resp: AxiosResponse): void;
    private static isSuccess;
    applyResource(resource: Resource, forceMigrate?: boolean): Promise<Resource>;
    getResourceByName(namespace: string, name: string): Promise<Resource>;
    listResources(): Promise<Resource[]>;
    createResource(resource: Resource, forceMigrate?: boolean): Promise<Resource>;
    updateResource(resource: Resource, forceMigrate?: boolean): Promise<Resource>;
    deleteResource(resource: Resource, forceMigrate?: boolean): Promise<void>;
    authenticateWithToken(token: string): Promise<void>;
    authenticateWithUsernameAndPassword(username: string, password: string): Promise<void>;
    newClientAuthenticateWithToken(token: string): Client;
    newClientAuthenticateWithUsernameAndPassword(username: string, password: string): Promise<Client>;
    headers(): {
        [key: string]: string;
    };
    getUrl(): string;
    bypassExtensions(bypassExtensions: boolean): void;
    listRecords<T extends Entity>(entityInfo: EntityInfo, params: ListRecordParams): Promise<Container<T>>;
    applyRecord<T extends Entity>(entityInfo: EntityInfo, record: Partial<T>): Promise<T>;
    deleteRecord<T extends Entity>(entityInfo: EntityInfo, id: string): Promise<T>;
    updateRecord<T extends Entity>(entityInfo: EntityInfo, record: Partial<T> & Entity): Promise<T>;
    getRecord<T extends Entity>(entityInfo: EntityInfo, params: GetRecordParams): Promise<T>;
    createRecord<T extends Entity>(entityInfo: EntityInfo, record: T): Promise<T>;
    loadRecord<T extends Entity>(entityInfo: EntityInfo, record: Partial<T>, resolveReferences?: string[]): Promise<T>;
    writeEvent(channelKey: string, event: Event): Promise<void>;
    repo<T extends Entity>(entityInfo: EntityInfo): Repository<T>;
    repository<T extends Entity>(entityInfo: EntityInfo): Repository<T>;
    static newClient(url: string | undefined): ClientImpl;
    static newClientByServerConfig(serverConfig: Server): Promise<ClientImpl>;
    private setupTokenRefresher;
    getTokenBody(): TokenBody | undefined;
    private ensureTokenFresh;
    refreshToken(): Promise<void>;
    isAuthenticated(): boolean;
    invalidateAuthentication(): void;
}
